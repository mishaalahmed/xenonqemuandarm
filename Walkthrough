Install QEMU for ARM64 emulation
You will need QEMU to emulate the ARM64 architecture on your x86_64 system. Install it using your package manager. In Ubuntu, you can use the following command:
sudo apt-get install qemu-system-arm

Download the ARM64 Xen
Obtain the ARM64 version of Xen suitable for your specific use case, usually from the official Xen project website or a trusted source.

Emulate ARM64 with QEMU
You can use QEMU to create a virtual ARM64 machine for running Xen. The command to do so may vary based on your specific use case . It often involves using qemu-system-aarch64 with the necessary options.

Ubuntu Specific Commands
This guide provides command that are Ubuntu-specific, you can generally follow them without modification. However, you may need to adapt or replace commands that are specific to other Linux distributions.

Adjust for Differences
Keep in mind that ARM64 and x86_64 systems have some fundamental differences, and you might encounter issues or variations in the steps. Be prepared to troubleshoot any errors or discrepancies that arise.
If you encounter any specific issues or have questions about adapting particular steps, please provide it in the comments, and I'll do my best to help you troubleshoot them. Additionally, be sure to check the original Xen Page for any ARM-specific recommendations or adjustments that you might need to make while following it on an x86_64-based system.

Error!
If this command is not working on Ubuntu:
./aarch64-softmmu/qemu-system-aarch64 -version

Solution! 
The error you're encountering with the qemu-system-aarch64 -version command suggests that the qemu-system-aarch64 binary is not in your system's PATH or that it may not be installed. To resolve this issue, you can try the following:
<Check if QEMU is Installed>
Ensure that QEMU for ARM64 emulation is installed on your Ubuntu system. You can check if it's installed by running the following:
dpkg -l | grep qemu
Look for a package that includes "qemu-system-aarch64." If it's not installed, you can install it with the following command:
sudo apt-get install qemu-system-aarch64
<Specify the Full Path>
If you know the full path to the qemu-system-aarch64 binary, you can run it by specifying the full path directly. For example:
/path/to/qemu/aarch64-softmmu/qemu-system-aarch64 -version
Replace /path/to/qemu with the actual path to your QEMU installation.
<Add QEMU to Your PATH>
To make it easier to use QEMU commands, you can add the directory containing qemu-system-aarch64 to your PATH. Open your shell profile file (e.g., ~/.bashrc, ~/.bash_profile, or ~/.zshrc) and add the following line:
export PATH=/path/to/qemu/aarch64-softmmu:$PATH
Save the file and then run source ~/.bashrc (or the appropriate profile file) to apply the changes immediately.
After trying these steps, you should be able to use the qemu-system-aarch64 -version command to check the QEMU version. If you encounter any issues or have more specific error messages, please provide them, and I'll assist you.

Error!
dpkg-query: package 'qemu-system-aarch64' is not installed
Use dpkg --contents (= dpkg-deb --contents) to list archive files contents.

Solution!
It seems that the qemu-system-aarch64 package is not installed on your system. In that case, you should install it using the following command:
sudo apt-get install qemu-system-aarch64
Once the package is installed, you can check its installation path and version using the dpkg command as previously mentioned:
dpkg -L qemu-system-aarch64
This will display the paths to the installed files associated with the qemu-system-aarch64 package. You can then locate the executable path, and, if needed, add it to your PATH for easy access.

<Note>
Selecting 'qemu-system-arm' instead of 'qemu-system-aarch64'
qemu-system-arm is already the newest version (1:6.2+dfsg-2ubuntu6.15).
The following packages were automatically installed and are no longer required:
initramfs-tools-bin klibc-utils libklibc
Use 'sudo apt autoremove' to remove them.
0 upgraded, 0 newly installed, 0 to remove and 5 not upgraded.

<Explanation>
It appears that you have the qemu-system-arm package installed on your system, but the specific qemu-system-aarch64 package isn't available or installed. This might explain the issue with running qemu-system-aarch64 -version.
Since qemu-system-arm is already installed and is used for ARM emulation, you can try using it for ARM64 (aarch64) emulation. While it's primarily meant for ARM, it can often handle ARM64 emulation as well. You can check its version and capabilities using the following command:
qemu-system-arm -version
If this works as expected, you should be able to use qemu-system-arm for ARM64 emulation in most cases.
If you encounter specific issues when using qemu-system-arm for ARM64 emulation or if your use case specifically requires qemu-system-aarch64, please provide the issue in comments so I can help.

<Note>
The gcc-aarch64-linux-gnu package provides a cross-compiler for the ARM64 (aarch64) architecture. It's used for compiling programs that can run on ARM64 systems. However, the qemu-system-arm emulator itself does not depend on this package for its own execution.
If you need to compile programs for ARM64 on your x86_64 (AMD64) Ubuntu system, you can indeed install gcc-aarch64-linux-gnu using the following command:
sudo apt install gcc-aarch64-linux-gnu
This will install the ARM64 cross-compiler, allowing you to compile ARM64 code on your x86_64 system. Keep in mind that this is separate from the qemu-system-arm package, which is an emulator for running ARM and, to some extent, ARM64 code on your system.

Creating a Project Directory
Create a working directory for your Xen on ARM64 project. You can follow these steps to set up your working directory:
Open a terminal in your Ubuntu system.
Change to your home directory with the following command:
cd ~
Define an environment variable for your working directory. In the guide, it's set to ~/Projects/xenonarm. You can create this variable using the export command:
export WORK_DIR=~/Projects/xenonarm
mkdir -pv $WORK_DIR
This will create the directory, and the -p option will also create any parent directories if they don't exist.
Change to your newly created working directory:
cd $WORK_DIR
Now you have a working directory at the path specified by the WORK_DIR environment variable, and you can proceed with the other steps in the guide within this directory.

Download BusyBox
The guide is instructing you to download the BusyBox source code and extract it. BusyBox is a software suite that provides various Unix utilities in a single executable. You can follow these steps to download and extract BusyBox:
Make sure you are in your working directory.
Use the wget command to download the BusyBox source code:
wget -c https://busybox.net/downloads/busybox-1.30.1.tar.bz2
This command will download the BusyBox source code archive named busybox-1.30.1.tar.bz2 from the specified URL.
After the download is complete, use the tar command to extract the contents of the archive:
tar xf busybox-1.30.1.tar.bz2
This command will extract the files from the busybox-1.30.1.tar.bz2 archive into a directory named busybox-1.30.1.
Now you have the BusyBox source code available in your working directory, and you can proceed with the next steps in the guide, which likely involve configuring and building BusyBox for your specific use case.
The directory where you download and extract the BusyBox source code should be the same directory where you created your working directory. In your case, it's the WORK_DIR that you previously defined as ~/Projects/xenonarm.
So, you should run the wget and tar commands within your working directory, which is ~/Projects/xenonarm. The guide assumes you are operating from this directory.
Here's a recap of the commands within your working directory:
cd ~/Projects/xenonarm
wget -c https://busybox.net/downloads/busybox-1.30.1.tar.bz2
tar xf busybox-1.30.1.tar.bz2
This sequence of commands will download and extract the BusyBox source code into the ~/Projects/xenonarm directory, which is where the rest of your Xen on ARM64 project is likely to be built and configured.

Create Temporary Folder
Now we have to create a folder for temporary files within your project's directory. You can follow these steps to create the temporary folder:
Make sure you are in your working directory, which is the one you created earlier (~/Projects/xenonarm).
Define an environment variable for the build directory. In the guide, it's set to ~/Projects/xenonarm/build:
export BUILD_DIR=~/Projects/xenonarm/build
You can customize the directory path to your liking if you prefer it to be located in a different directory or under a different name.
Create the temporary folder using the mkdir command with the -pv options:
mkdir -pv $BUILD_DIR/busybox_arm64
This command will create the directory, and the -p option will also create any parent directories if they don't exist.
Now you have a temporary folder within your project's build directory where you can store temporary files or perform specific tasks as needed during your project setup.

Building BusyBox
Here I provide instructions for building BusyBox with specific configuration options for ARM64. Here are the steps you should follow:
Change to the BusyBox source code directory. Based on the guide, it should be located in your working directory:
cd $WORK_DIR/busybox-1.36.1
Configure BusyBox with the appropriate options for ARM64. Use the make command with the defconfig target and set the output directory to your temporary build directory. You will also need to specify the architecture and cross-compiler:
make O=$BUILD_DIR/busybox_arm64/ ARCH=arm CROSS_COMPILE=aarch64-linux-gnu- defconfig
Open the configuration menu for BusyBox using make menuconfig:
make O=$BUILD_DIR/busybox_arm64/ ARCH=arm CROSS_COMPILE=aarch64-linux-gnu- menuconfig
In the configuration menu, make sure to save the configuration you create (e.g., as "new_config"). After saving, you can exit the menuconfig.
Open the created configuration file, which should be named "new_config," and add the line CONFIG_STATIC=y to make BusyBox compile as a static library:
echo "CONFIG_STATIC=y" >> new_config
Save the "new_config" file.
Copy the modified configuration file to .config to apply the changes:
cp new_config .config
Now you have configured BusyBox for ARM64 and set it to compile as a static library. You can proceed with building BusyBox by running make:
make O=$BUILD_DIR/busybox_arm64/ ARCH=arm CROSS_COMPILE=aarch64-linux-gnu-
This will compile BusyBox with the specified configuration for ARM64 and save the resulting binaries in your temporary build directory.

Error!
If this command dont work it gives error 
"make O=$BUILD_DIR/busybox_arm64/ ARCH=arm CROSS_COMPILE=aarch64-linux-gnu-"
error is "
Using /home/mishaal-retis/Projects/xenonarm/busybox-1.36.1 as source for busybox
/home/mishaal-retis/Projects/xenonarm/busybox-1.36.1 is not clean, please run 'make mrproper'
in the '/home/mishaal-retis/Projects/xenonarm/busybox-1.36.1' directory.
make[1]: *** [/home/mishaal-retis/Projects/xenonarm/busybox-1.36.1/Makefile:807: prepare3] Error 1
make: *** [Makefile:112: _all] Error 2

Solution!
The error you're encountering is related to the fact that the BusyBox source directory is not clean, and the make process is expecting it to be clean before building. To resolve this issue, you can run make mrproper in the BusyBox source directory, as the error message suggests. This command will clean the source directory and prepare it for a fresh build. Here's how to do it:
Change to the BusyBox source directory:
cd $WORK_DIR/busybox-1.36.1
Run the make mrproper command to clean the source directory:
make mrproper
After running make mrproper, you can proceed with the make command to build BusyBox:
make O=$BUILD_DIR/busybox_arm64/ ARCH=arm CROSS_COMPILE=aarch64-linux-gnu-
This should resolve the issue, and BusyBox should build without errors. If you encounter any further issues or have more questions, please feel free to ask.

Installing BusyBox
Now we have to build and install BusyBox with specific options for ARM64. You can follow these steps:
Build BusyBox by running the make command with the -j2 option. This option specifies the number of parallel jobs to use for the build. In this case, it's set to 2:
make -j2 O=$BUILD_DIR/busybox_arm64/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
This command will compile BusyBox with the specified options.
After the build is complete, you can install BusyBox using the make install command:
make install O=$BUILD_DIR/busybox_arm64/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
This command will install the compiled BusyBox binaries and associated files into the specified build directory.
With these steps, you should have a built and installed version of BusyBox configured for ARM64 in your temporary build directory.

Creating Root File System
Now we have to create a minimal root filesystem. Here are the steps to follow:
Change to the _install directory:
cd _install/
Create the necessary directories for your root filesystem. I suggest creating directories like proc, sys, dev, etc, and etc/init.d:
mkdir proc sys dev etc etc/init.d
Create a startup script in the etc/init.d directory. You can use a text editor like vim to create the script:
vim etc/init.d/rcS
In the rcS script, add the following lines to mount proc and sys filesystems and run mdev:
#! /bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
Save the file and make it executable:
chmod +x etc/init.d/rcS
Return to the _install directory:
cd ..
Create the root filesystem image using the find and cpio commands. This will package the contents of the _install directory into a root filesystem image:
cd _install
find . | cpio -o --format=newc > ../rootfs.img
cd ..
Compress the root filesystem image using gzip:
gzip -c rootfs.img > rootfs.img.gz
Copy the compressed root filesystem image to your build directory, which is specified as $BUILD_DIR/busybox_arm64:
cp rootfs.img.gz $BUILD_DIR/busybox_arm64/
Now, you have created a minimal root filesystem image and placed it in your build directory. This image can be used with the ARM64 environment.

Error!
mishaal-retis@mishaalretis-System-Product-Name:~/Projects/xenonarm/busybox-1.36.1$ cd _install/
bash: cd: _install/: No such file or directory

Solution!
It seems that the _install directory is not present within your current working directory, which is the BusyBox source code directory (busybox-1.36.1). This might be due to an issue in a previous step.
You can try the following to resolve the issue:
Double-check that you've followed all the previous steps correctly, especially the ones related to configuring and building BusyBox. Make sure there were no errors during the build process.
Verify that the _install directory was created within the BusyBox source directory by listing the contents of the current directory:
ls
If you don't see the _install directory listed, it means it wasn't created. In that case, you may need to investigate what went wrong during the build process or the instructions for creating the root filesystem.
If you are certain that you followed the instructions correctly and still don't have the _install directory, you might want to double-check your project's structure and ensure that you are in the correct directory.

Error!
If there is no _install directory

Solution!
If the _install directory is missing, it indicates that there was an issue in the previous steps where it should have been created. To address this, you can manually create the _install directory and then proceed with the rest of the steps:

Navigate to your BusyBox source code directory:
cd ~/Projects/xenonarm/busybox-1.36.1
Create the _install directory:
mkdir _install
Now, you can proceed by starting from creating the necessary directories and creating the root filesystem:
cd _install
mkdir proc sys dev etc etc/init.d
vim etc/init.d/rcS  # Add the startup script as instructed
chmod +x etc/init.d/rcS
cd ..
find _install | cpio -o --format=newc > rootfs.img
gzip -c rootfs.img > rootfs.img.gz
cp rootfs.img.gz $BUILD_DIR/busybox_arm64/
By manually creating the _install directory, you should be able to proceed with the creation of the root filesystem image.

Note!
when i use this command "
find . | cpio -o --format=newc > ../rootfs.img
it shows" mishaal-retis@mishaalretis-System-Product-Name:~/Projects/xenonarm/build/busybox_arm64/_install$ find . | cpio -o --format=newc > ../rootfs.img 2376 blocks"
The message you're seeing, "2376 blocks," indicates that the find command successfully generated a cpio archive, which was then redirected to the file rootfs.img in the parent directory (../).
So, the command find . | cpio -o --format=newc > ../rootfs.img successfully created the root filesystem image rootfs.img in your parent directory, which should contain the files and directory structure you configured within the _install directory. 

Building Linux Kernel for Arm64
To build the Linux kernel for ARM64. You should follow these steps:
Change to the Linux kernel source code directory, which is specified as $WORK_DIR/linux-4.20.11/ in the guide:
cd $WORK_DIR/linux-4.20.11/
Configure the kernel by running make with the defconfig target, specifying the architecture and cross-compiler:
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
This command will load the default configuration for ARM64.
Edit the .config file to add the following lines if they are not already present:
CONFIG_XEN_DOM0=y
CONFIG_XEN=y
These lines are required to enable Xen support in the kernel configuration.
Build the kernel with the specified options, using -j4 to parallelize the build:
make -j4 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
This will compile the Linux kernel with Xen support.
After the kernel build is complete, you can copy the generated kernel image to your build directory:
cp ./arch/arm64/boot/Image.gz $BUILD_DIR/busybox_arm64/
Now, you should have the Linux kernel built and copied to your specified build directory ($BUILD_DIR/busybox_arm64/). You can proceed with the remaining steps for setting up Xen on ARM64 with your prepared kernel and root filesystem.

Running QEMU with built Linnux kernel
The command provided in the guide is for running QEMU with your built Linux kernel and BusyBox-based root filesystem. Here's a breakdown of the command and what it does:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -kernel Image.gz -nographic -no-reboot -initrd rootfs.img.gz -append "rw root=/dev/ram rdinit=/sbin/init earlyprintk=serial,ttyAMA0 console=ttyAMA0"
qemu-system-aarch64: This is the QEMU command for running a virtual machine with ARM64 architecture.
-machine virt,gic_version=3 -machine virtualization=true: These options configure the virtual machine to use the virt machine type with GICv3 support and enable virtualization.
-cpu cortex-a57: Specifies the CPU type as Cortex-A57.
-machine type=virt: Sets the machine type to virt.
-m 4096: Allocates 4096MB (4GB) of RAM to the virtual machine.
-smp 4: Configures the virtual machine with 4 CPU cores.
-kernel Image.gz: Specifies the path to the Linux kernel image (Image.gz) that you built earlier. This kernel will be used to boot the virtual machine.
-nographic: Runs QEMU in a non-graphical mode, which means you'll interact with the virtual machine through the terminal.
-no-reboot: Prevents the virtual machine from automatically rebooting in case of a system shutdown.
-initrd rootfs.img.gz: Specifies the initial ramdisk (initrd) image to use for the root filesystem. It points to the rootfs.img.gz you created earlier.
-append "rw root=/dev/ram rdinit=/sbin/init earlyprintk=serial,ttyAMA0 console=ttyAMA0": Provides kernel command-line parameters. These parameters specify the boot options, such as mounting the root filesystem as read-write, setting the initial ramdisk, configuring the early printk, and defining the console.
You can run this QEMU command in your terminal to start the virtual machine with your configured Linux kernel and BusyBox-based root filesystem. It will allow you to interact with the virtual machine through the terminal.
Please ensure that you are in the correct directory where your kernel image and root filesystem are located, and then execute the command as provided in the guide.

Note!
If you ran the command but cannot exit the boooting process
In QEMU, to exit the virtual machine or the booting process, you typically have a few options:
Press Ctrl + a followed by x: This is the default key combination to exit QEMU. Pressing Ctrl + a and then x will gracefully shut down the virtual machine.
Press Ctrl + c: This key combination can also interrupt the QEMU process and return you to the QEMU monitor. From there, you can issue further commands or stop the virtual machine.
If the virtual machine is running in the background, you can close the terminal: If you ran QEMU in the background, closing the terminal where you started the virtual machine will terminate the QEMU process.
If you are unable to exit gracefully: In some cases, you might encounter situations where the virtual machine is unresponsive or stuck. In such cases, you can use Ctrl + Alt + 2 to switch to the QEMU monitor, and then use the quit command to forcefully terminate the QEMU process. This should be used as a last resort, as it forcefully terminates the virtual machine.
Remember that the key combinations can vary depending on your system configuration or the QEMU version you're using. If the default combinations don't work, you can consult the documentation for your specific version of QEMU or try searching for any modifications to the key bindings in your environment.
It's essential to use these options to exit the virtual machine gracefully whenever possible to avoid data corruption or other issues.

Setup U-Boot
Now we have to set up U-Boot and use it to boot the Linux kernel in a QEMU virtual machine. Here are the steps to follow:
Download and extract U-Boot:
wget -c ftp://ftp.denx.de/pub/u-boot/u-boot-2019.01.tar.bz2
tar xf u-boot-2019.01.tar.bz2
Change to the U-Boot source code directory:
cd u-boot-2019.01
Configure U-Boot for QEMU ARM64:
make CROSS_COMPILE=aarch64-linux-gnu- qemu_arm64_defconfig
Edit the U-Boot configuration file (.config) and add the following lines if they are not already present:
CONFIG_ARCH_QEMU=y
CONFIG_TARGET_QEMU_ARM_64BIT=y
These lines configure U-Boot for the QEMU virtual machine and the ARM64 architecture.
Build U-Boot with the specified options, using -j4 to parallelize the build:
make CROSS_COMPILE=aarch64-linux-gnu- -j4
Copy the U-Boot binary to your build directory:
cp u-boot.bin $BUILD_DIR/busybox_arm64/
Change to your build directory:
cd $BUILD_DIR/busybox_arm64/
Start QEMU with U-Boot to boot Linux:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 512M -bios u-boot.bin -device loader,file=Image,addr=0x45000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
This command starts QEMU with U-Boot as the bootloader, loads the Linux kernel (Image) into memory, and configures the monitor for interaction.
After QEMU starts with U-Boot, you can boot the Linux kernel with the following command within the QEMU monitor:
bootm 0x45000000 - 0x40000000
This command boots the Linux kernel. The address 0x45000000 is the address of your kernel image, and 0x40000000 is the default address of the QEMU device tree blob.
With these steps, you should be able to boot the Linux kernel using U-Boot in QEMU and test its operation. Note that, you haven't yet provided a root filesystem, so the kernel may fail to load it. You can continue configuring and testing your setup based on your specific project requirements.

Note!
If you are confused in which directory you should extract U-Boot
You have to download and extract U-Boot in your working directory. In your case, your working directory is ~/Projects/xenonarm. You should follow these steps:
Open a terminal.
Navigate to your working directory:
cd ~/Projects/xenonarm
Download U-Boot and extract it in your working directory:
wget -c ftp://ftp.denx.de/pub/u-boot/u-boot-2019.01.tar.bz2
tar xf u-boot-2019.01.tar.bz2
These commands will download U-Boot and extract it in your ~/Projects/xenonarm directory. You can then proceed with the U-Boot configuration and building steps.

Error!
At step 8 I faced the following issue 
"
mishaal-retis@mishaalretis-System-Product-Name:~/Projects/xenonarm/build/busybox_arm64$ qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 512M -bios u-boot.bin -device loader,file=Image,addr=0x45000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'server' deprecated
Please use server=on instead
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'nowait' deprecated
Please use wait=off instead
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'telnet' deprecated
Please use telnet=on instead
Image: No such file or directory
qemu-system-aarch64: -device loader,file=Image,addr=0x45000000: Cannot load specified image Image

Solution!
The error message indicates that QEMU is unable to find the Image file specified in the -device option. The issue likely stems from either the location of the Image file or a naming discrepancy.
Here are some steps to resolve the issue:
Verify the Image file location:
Ensure that the Image file exists in the same directory where you are running the QEMU command (~/Projects/xenonarm/build/busybox_arm64/).
Verify that the Image file has the correct name and case sensitivity. It should match the name used in the command.
If the Image file exists in the correct location but still cannot be found, it's possible that you may need to specify the full path to the Image file in your QEMU command, rather than a relative path. For example:
-device loader,file=/full/path/to/your/Image,addr=0x45000000
Make sure that the name and case of the file match exactly. Linux is case-sensitive, so if the file is named "image" instead of "Image," it will not be found.
Double-check the existence, location, and name of the Image file, and ensure that it matches the reference in your QEMU command. If there are any discrepancies, correcting them should resolve the issue.

Error!
at step  9 I faced the following issue:
=> bootm 0x45000000 - 0x40000000
Wrong Image Format for bootm command
ERROR: can't get kernel image!

Solution!
The error message "Wrong Image Format for bootm command" indicates that U-Boot is unable to recognize the format of the image specified in the bootm command. It's likely that the image format of the Linux kernel is not compatible with U-Boot's bootm command.
To resolve this issue, you should ensure that the Linux kernel image is in a format that U-Boot can recognize. In many cases, U-Boot expects the kernel image to be in a specific format, typically a U-Boot-specific format or a standard format like a uImage.
Here are some steps you can take to address the issue:
Check the Kernel Image Format: First, make sure that the Linux kernel image (Image) is built in a format that U-Boot can recognize. U-Boot commonly expects the kernel image to be in the uImage format. You might need to convert your kernel image to this format if it's not already.
Build a U-Boot-Compatible Kernel Image: If your kernel image is not in the right format, you can build a kernel image that's compatible with U-Boot. You'll typically need to use U-Boot's tools or scripts to create a kernel image in the correct format.
Load the Kernel Correctly: Ensure that the address specified in the bootm command matches the actual location of the kernel image in memory. The address 0x45000000 should be the address where your kernel image is loaded, and it should match the actual address where the kernel is located.
Check U-Boot Configuration: Review the configuration settings in U-Boot (e.g., bootcmd) to ensure that they correctly point to the location of the kernel image and its format.
Consult U-Boot Documentation: U-Boot configurations and kernel image format requirements can vary depending on the version of U-Boot and the board you are using. Consult the U-Boot documentation specific to your setup for guidance.
Remember to match the kernel image format with what U-Boot expects and ensure the correct memory address is specified in the bootm command. This should help you boot the Linux kernel successfully from U-Boot.

Note!
If you are using Image.gz
If you are using Image.gz as your kernel image file and encounter the "Wrong Image Format for bootm command" error, it's possible that U-Boot is not recognizing the compression format. In this case, U-Boot expects a specific image format and does not automatically handle compressed kernel images. Here are steps to address this issue:
Decompress the Kernel Image: U-Boot typically expects an uncompressed kernel image. If your Image.gz is compressed, you should decompress it using the appropriate tool. The most common format for the Linux kernel image is a uImage. You can use the mkimage tool that comes with U-Boot to create a uImage from the uncompressed kernel image. First, decompress the kernel image:
gunzip Image.gz
Create a uImage: After decompressing the kernel image, create a uImage:
mkimage -A arm64 -O linux -T kernel -C none -a 0x45000000 -e 0x45000000 -n "Linux Kernel" -d Image uImage
his command creates a uImage from the uncompressed kernel image, specifying the architecture as arm64, the machine type as "none" compression type as "none," and setting the load address (-a) and entry point address (-e) to match the bootm command in U-Boot.
Copy the newly created uImage to the location where U-Boot can access it.
In your U-Boot environment, modify the bootcmd or other relevant settings to point to the uImage file instead of the compressed Image.gz.
Try running the bootm command again in U-Boot. It should now recognize and boot the decompressed uImage format of the kernel image.
By converting the kernel image to a uImage, U-Boot should be able to recognize the format and load it properly.

Error!
mishaal-retis@mishaalretis-System-Product-Name:~/Projects/xenonarm/build/busybox_arm64$ qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 512M -bios u-boot.bin -device loader,file=uImage,addr=0x45000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'server' deprecated
Please use server=on instead
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'nowait' deprecated
Please use wait=off instead
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: warning: short-form boolean option 'telnet' deprecated
Please use telnet=on instead
qemu-system-aarch64: -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet: Failed to find an available port: Address already in use

Solution!
The error message indicates that the port 7777 is already in use by another application or service, and QEMU is unable to bind to it for the telnet monitor connection.
To resolve this issue, you can do the following:
Specify a Different Port: You can specify a different port for the telnet monitor connection by changing the port number in the QEMU command. For example, you can use port 7778:
-chardev socket,id=qemu-monitor,host=localhost,port=7778,server,nowait,telnet
Ensure that the specified port is not in use by other applications.
Release the Port: If you want to use port 7777, you need to find the application or service that is currently using it and stop or reconfigure that application. To find the application using port 7777, you can use a command like netstat or lsof. Here's an example using lsof:
sudo lsof -i :7777
This will show you the process that is using the port. Once you identify the process, you can either stop it or change its configuration to use a different port.
Terminate the Previous QEMU Instance: It's possible that you have a previous QEMU instance running in the background, using the same port. Make sure that you've exited any previous QEMU instances and try running the command again.
Choose the option that best suits your needs, whether it's specifying a different port, identifying and stopping the application using the port, or ensuring that there are no previous QEMU instances running.

Build Xen
Now we have to build Xen for the ARM64 architecture and copy the resulting image to your build directory. Here's how you can do that:
Build Xen for ARM64
make dist-xen XEN_TARGET_ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
This command will build Xen for ARM64 using the specified cross-compiler (aarch64-linux-gnu-) and target architecture (arm64).
Copy the Xen raw image to your build directory:
cp xen/xen $BUILD_DIR/busybox_arm64/
This command copies the generated Xen image (xen) to the directory where you are building your project.
Now, you should have the Xen image ready in your build directory for the further setup as described in the guide. Please proceed with the remaining steps based on the guide's instructions to set up Xen on ARM64 with your kernel, root filesystem, and Xen image.

Note!
If you are confused on which directory should you be on the first step
For the first step of building Xen for ARM64, you should be in the directory where you have Xen's source code. The guide provided does not specify the exact directory, so I'll assume that the Xen source code is located within your project directory, which you've been using throughout the guide.
Based on your previous steps, it seems your project directory is ~/Projects/xenonarm. You can navigate to your project directory using the following command:
cd ~/Projects/xenonarm
Once you are in your project directory, you can proceed with the step to build Xen:
make dist-xen XEN_TARGET_ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-
This command should be executed from your project directory, assuming the Xen source code is present there. After the build is complete, you can then copy the Xen raw image to your build directory.
Make sure the Xen source code is present in your project directory or navigate to the appropriate directory where the Xen source code is located before running the build command.

Run Xen,Linux and BusyBox
Now we have to run Xen, Linux, and Busybox on QEMU for ARM64. Here's a breakdown of the steps:
Generate a Device Tree Blob:
Use QEMU to generate a device tree blob by running the following command:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -display none -machine dumpdtb=virt-gicv3.dtb

Run Xen with Linux as Dom0:
Use QEMU to run Xen with Linux as Dom0. This command loads Xen, the Linux kernel (Image.gz), and the generated device tree blob:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -bios u-boot.bin -device loader,file=xen,force-raw=on,addr=0x49000000 -device loader,file=Image.gz,addr=0x47000000 -device loader,file=virt-gicv3.dtb,addr=0x44000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
Modify the device tree blob by running the following commands in U-Boot (substitute the correct value for the size of Image.gz in the <0x47000000 0x7F31CE> line):
fdt addr 0x44000000
fdt resize
fdt set /chosen \#address-cells <1>
fdt set /chosen \#size-cells <1>
fdt mknod /chosen module@0
fdt set /chosen/module@0 compatible "xen,linux-zimage" "xen,multiboot-module"
fdt set /chosen/module@0 reg <0x47000000 0x7F31CE>
fdt set /chosen/module@0 bootargs "earlyprintk=serial,ttyAMA0 console=ttyAMA0,115200n8 earlycon=xenboot"
booti 0x49000000 - 0x44000000
Calculate the size of Image.gz with the following command:
printf "0x%x\n" $(stat -c %s Image.gz)
Run Xen, Linux, and Busybox:
Use QEMU to run Xen, Linux, and Busybox. This command also modifies the device tree blob with the size of rootfs.img.gz:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -bios u-boot.bin -device loader,file=xen,force-raw=on,addr=0x49000000 -device loader,file=Image.gz,addr=0x47000000 -device loader,file=virt-gicv3.dtb,addr=0x44000000 -device loader,file=rootfs.img.gz,addr=0x42000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
Modify the device tree blob in U-Boot to specify the size of rootfs.img.gz in the <0x42000000 0x121e65> line.
Check System Operation:
After executing the commands, you should see an input prompt. You can check the system's operation by running the uname command. If everything is set up correctly, you should see "Linux" as the output.
Please follow these steps as outlined in the guide to run Xen, Linux, and Busybox on QEMU for ARM64. Be sure to replace any placeholder values with the correct file sizes and addresses based on your specific setup.

Note!
Confused? On which directory you should be on?

For the first step, which involves generating a device tree blob, you should be in the directory where you have your QEMU project or where your QEMU command is executed. Based on the previous steps in the guide and the directory structure mentioned in your previous questions, it appears that your working directory is ~/Projects/xenonarm.
You can navigate to this directory using the following command:
cd ~/Projects/xenonarm
Once you are in the ~/Projects/xenonarm directory, you can execute the QEMU command to generate the device tree blob as instructed in the guide:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -display none -machine dumpdtb=virt-gicv3.dtb
This command should be executed from your project directory.
If this appears:
mishaal-retis@mishaalretis-System-Product-Name:~/Projects/xenonarm$ qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -display none -machine dumpdtb=virt-gicv3.dtb
qemu-system-aarch64: info: dtb dumped to virt-gicv3.dtb. Exiting.
**Great, it appears that the device tree blob (virt-gicv3.dtb) has been successfully generated, and the QEMU command executed without errors. You can now proceed with the next steps in the guide to run Xen, Linux, and Busybox on QEMU.**
Just make sure you're following the subsequent steps to set up and boot your system as described, and you should be on your way to running your ARM64 virtualized environment on QEMU. 

Note!
On which directory should I be on step 2?
For the second step, where you run Xen with Linux as Dom0 on QEMU, you should also be in the same directory where you've been working on your project, specifically the ~/Projects/xenonarm directory, as indicated in your previous steps.
So, navigate to your project directory using the following command:
cd ~/Projects/xenonarm
Once you're in the ~/Projects/xenonarm directory, you can execute the QEMU command and U-Boot commands to run Xen and Linux as Dom0. The relevant QEMU command and U-Boot commands should be executed from this directory.
Please make sure you're in the correct directory before proceeding with the steps to ensure that the paths to your files and configuration are accurate.

Confused?
i dont know how to exactly do this 
" Modify the device tree blob in U-Boot to specify the size of rootfs.img.gz in the <0x42000000 0x121e65> line."
Modifying the device tree blob in U-Boot to specify the size of rootfs.img.gz in the <0x42000000 0x121e65> line involves using U-Boot's commands to edit the device tree binary. Here's a step-by-step guide on how to perform this modification:
Boot into U-Boot: Make sure you are at the U-Boot command prompt, where you can enter U-Boot commands. If you have executed the QEMU command as per the guide, you should be at the U-Boot command prompt.
Load the Device Tree Blob (DTB): Use the fdt addr command to specify the memory address where the device tree blob is located. In your case, the address is 0x44000000:
fdt addr 0x44000000
Resize the Device Tree Blob: You need to resize the device tree blob to make space for modifications:
fdt resize
Set the Necessary Properties: Use U-Boot commands to set the properties within the device tree blob that specify the size of rootfs.img.gz and other relevant information. In your case, you are modifying a property related to the module at address 0x42000000. Use the fdt set command to specify the size of rootfs.img.gz. Here's an example:
fdt set /chosen/module@1 reg <0x42000000 0x121e65>
In this command, you are setting the reg property of the module at address 0x42000000 to <0x42000000 0x121e65>. The first value in the angle brackets is the starting address, and the second value is the size of rootfs.img.gz.
Save Your Changes: U-Boot typically automatically updates the device tree blob in memory when you use the fdt set command. However, you can ensure that your changes are saved by using the fdt resize command again or by rebooting.
Boot: After you've made the necessary modifications, you can continue with booting by using the booti command:
booti 0x49000000 - 0x44000000
These U-Boot commands allow you to access and modify the device tree blob in memory to reflect the correct size of rootfs.img.gz. Make sure to replace the values in the fdt set command with the correct memory address and size according to your specific setup.
Once you've made these modifications you should boot with the adjusted parameters.

Error!
Tt shows 
"
=> fdt resize
=> fdt set /chosen/module@1 reg <0x42000000 0x121e65>
libfdt fdt_path_offset() returned FDT_ERR_NOTFOUND
=> 

The error message you received, "libfdt fdt_path_offset() returned FDT_ERR_NOTFOUND," indicates that U-Boot couldn't find the specified path in the device tree blob (DTB). It seems that U-Boot couldn't locate the /chosen/module@1 path in the DTB, possibly because the path or node you're trying to modify doesn't exist in your DTB.

Solution!
Here's what you can do to resolve this issue:
Check the DTB Structure: Confirm that the DTB structure matches the path you are trying to access and modify. You can use the fdt print command to view the DTB structure and identify the correct path:
fdt print
This will display the current structure of the device tree blob. Ensure that the /chosen/module@1 path and node exist as expected. If not, you may need to adjust the path based on your specific DTB structure.
Verify DTB Location: Double-check that the device tree blob (DTB) is loaded at the correct memory address (0x44000000) as specified in your U-Boot environment. If the DTB is located at a different address, you should use the correct address in the fdt addr command.
Modify the Correct Node: Make sure you are modifying the correct node within the device tree. If the node you want to modify isn't named /chosen/module@1, locate the correct node and specify its path in the fdt set command.
Ensure DTB Is Loaded: Ensure that the device tree blob is successfully loaded into memory before attempting to modify it. Check that there are no errors or issues related to DTB loading in the U-Boot console.
Once you have identified the correct path within the DTB and made any necessary adjustments, retry the fdt set command. If the path is still not found, you may need to consult the documentation or resources specific to your setup to determine the correct DTB path for your modifications.

Issue!
I decompressed the image and used the following command 
" mkimage -A arm64 -O linux -T kernel -C none -a 0x45000000 -e 0x45000000 -n "Linux Kernel" -d Image uImage "
now i am running this command to run xen linux as dom0
"
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -bios u-boot.bin -device loader,file=xen,force-raw=on,addr=0x49000000 -device loader,file=Image.gz,addr=0x47000000 -device loader,file=virt-gicv3.dtb,addr=0x44000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline
"

Confused?
Do i have to change the address of the image?
It's good that you've created a uImage from the Image kernel. The address you specify for the kernel image in the QEMU command is 0x47000000. If you've created a uImage, you should use the address of this uImage file. So, if you've used mkimage to create a uImage, and the uImage file is located at address 0x47000000, you don't need to change the address.
However, make sure that the uImage file contains the kernel image (Image) and that it's correctly formatted for use with U-Boot. The uImage should encapsulate the kernel image and include U-Boot headers.
If you have any doubts about the correctness of your uImage, you should verify its content and format. Additionally, ensure that the virt-gicv3.dtb and other components are correctly specified in your QEMU command based on your setup.
As long as you've created a valid uImage file and the addresses in your QEMU command match your setup, you can proceed with the QEMU execution.

Issue!
What should be the modified command "
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -bios u-boot.bin -device loader,file=xen,force-raw=on,addr=0x49000000 -device loader,file=Image.gz,addr=0x47000000 -device loader,file=virt-gicv3.dtb,addr=0x44000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline

If you've created a uImage and the address of the uImage is still 0x47000000, then your QEMU command should remain the same. Here's the command you provided for reference:
qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=true -cpu cortex-a57 -machine type=virt -m 4096 -smp 4 -bios u-boot.bin -device loader,file=xen,force-raw=on,addr=0x49000000 -device loader,file=Image.gz,addr=0x47000000 -device loader,file=virt-gicv3.dtb,addr=0x44000000 -nographic -no-reboot -chardev socket,id=qemu-monitor,host=localhost,port=7777,server,nowait,telnet -mon qemu-monitor,mode=readline

This command specifies the addresses for Xen, the kernel image (Image.gz), and the device tree blob (virt-gicv3.dtb) based on the addresses in your setup. If you've created a uImage and it's located at 0x47000000, you don't need to modify the address in the QEMU command.
Just make sure that your uImage is correctly formatted and contains the kernel image (Image) and the U-Boot headers. If you have any doubts about the correctness of your uImage, verify its content and format.
Other components and addresses in your QEMU command, such as Xen and the device tree blob, should also be correctly specified based on your setup.
The provided U-Boot commands are designed to modify the device tree blob (DTB) to specify the size of rootfs.img.gz. If you have created a uImage for your kernel, you may need to adjust these commands slightly to ensure they reference the correct addresses. Specifically, the memory addresses in these commands should match your setup.
Here's how the U-Boot commands can be modified to suit a uImage and potentially different memory addresses:
Assuming your uImage is located at address 0x47000000, and you want to specify the size of rootfs.img.gz in your uImage, you can modify the commands as follows:
Boot into U-Boot, ensuring that you are at the U-Boot command prompt.
Load the Device Tree Blob (DTB) at the correct address, typically 0x44000000:
fdt addr 0x44000000
Resize the Device Tree Blob:
fdt resize
Set the Necessary Properties. In this case, if you want to specify the size of rootfs.img.gz within your uImage, you should use the correct path for the uImage node (it may be different based on your system's DTB):
fdt set /chosen/module@0 reg <0x47000000 size>
Replace <0x47000000 size> with the appropriate values for the address and size of rootfs.img.gz within your uImage. Be sure to refer to the actual path and property name within your DTB.
Save Your Changes. U-Boot typically updates the DTB in memory when you use the fdt set command.
Boot. After making the necessary modifications, continue with booting by using the booti command, ensuring it references the correct addresses:
booti 0x49000000 - 0x44000000
Remember to replace 0x49000000 and 0x44000000 with the actual memory addresses for Xen and the DTB in your setup.
These modifications are specific to your configuration and may vary depending on the actual structure of your DTB and the organization of the uImage. Be sure to check your DTB structure and understand the paths and properties you need to modify to specify the size of rootfs.img.gz within your uImage.
Based on the provided device tree blob (DTB) information, you can use U-Boot's fdt set command to modify specific properties within the DTB. To specify the size of rootfs.img.gz within your uImage, you should locate the appropriate node in your DTB and set the reg property. In your DTB, it appears to be under the /chosen/module@0 node.
Here's the modified fdt set command:
fdt set /chosen/module@0 reg <0x47000000 0xYOUR_SIZE>
Replace 0xYOUR_SIZE with the size of rootfs.img.gz in hexadecimal format. Make sure the size is correctly calculated and expressed in hexadecimal. You need to replace 0x47000000 with the correct address where your uImage is located.
After running this command, the DTB will be modified with the new size for rootfs.img.gz. Save your changes by ensuring U-Boot updates the DTB in memory, and then continue with the boot process.

Error!
If it shows "
=> fdt set /chosen/module@0 reg <0x47000000 0x274ea00>  
libfdt fdt_path_offset() returned FDT_ERR_NOTFOUND
"

Solution!
It means that the path /chosen/module@0 does not exist in your device tree blob (DTB). The path and nodes in the DTB might vary depending on the specific configuration of your system. You will need to find the correct path to the node that corresponds to the module containing rootfs.img.gz size information.
Here's what you can do to locate the correct path:
Use the fdt print command to display the entire device tree blob. This will give you a better understanding of the available nodes and their paths.
Look for a node that might correspond to your module or the kernel image and its properties. You should typically find a node specifying the kernel's memory location, and within it, you can modify the reg property.
Once you've identified the correct path to the node, use the fdt set command as mentioned earlier, replacing the path and values accordingly.
If you have trouble finding the correct path or node in your device tree blob, you may want to consult your system's documentation or the resources provided with your hardware or board to identify the correct location to modify the reg property for the size of rootfs.img.gz.

Modifying the Device Tree Blob:
The guide you provided seems to offer specific instructions for modifying the device tree blob in U-Boot to load Xen and the Linux kernel. Here's how to execute the commands in your case:
Set the base address of the device tree blob (DTB) with fdt addr:
fdt addr 0x44000000
Resize the device tree blob with fdt resize:
fdt resize
Set the #address-cells and #size-cells properties for /chosen node:
fdt set /chosen \#address-cells <1>
fdt set /chosen \#size-cells <1>
Create a new node /chosen/module@0:
fdt mknod /chosen module@0
Set properties for the new node /chosen/module@0:
Set the compatible property:
fdt set /chosen/module@0 compatible "xen,linux-zimage" "xen,multiboot-module"
Set the reg property for the module specifying the location and size of rootfs.img.gz. In your case, this might differ depending on the actual location and size of rootfs.img.gz. You should adjust the values accordingly:
fdt set /chosen/module@0 reg <0x47000000 0x7F31CE>
Set the bootargs property if needed:
fdt set /chosen/module@0 bootargs "earlyprintk=serial,ttyAMA0 console=ttyAMA0,115200n8 earlycon=xenboot"
Boot the system using the modified device tree blob and the Xen + Linux kernel images:
booti 0x49000000 - 0x44000000
These commands follow the instructions provided  should allow you to boot Xen and Linux with the adjusted parameters. Make sure to replace the reg values with the correct memory address and size for rootfs.img.gz based on your specific setup.

END OF THE WALKTHROUGH
******************************

